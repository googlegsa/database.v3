// Copyright 2011 Google Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.google.enterprise.connector.db;

import com.google.common.io.ByteStreams;
import com.google.common.io.Files;
import com.google.enterprise.connector.db.diffing.JsonDocument;
import com.google.enterprise.connector.db.diffing.JsonDocumentUtil;
import com.google.enterprise.connector.spi.Property;
import com.google.enterprise.connector.spi.RepositoryException;
import com.google.enterprise.connector.spi.SkippedDocumentException;
import com.google.enterprise.connector.spi.SpiConstants;
import com.google.enterprise.connector.spi.Value;
import com.google.enterprise.connector.spiimpl.BinaryValue;
import com.google.enterprise.connector.traversal.FileSizeLimitInfo;
import com.google.enterprise.connector.traversal.MimeTypeMap;
import com.google.enterprise.connector.traversal.ProductionTraversalContext;
import com.google.enterprise.connector.util.MimeTypeDetector;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.logging.Logger;

public class JsonDocumentUtilTest extends DBTestBase {
  private static final Logger LOG =
      Logger.getLogger(JsonDocumentUtilTest.class.getName());
  public static final String ROW_CHECKSUM = "dbconnector:checksum";

  /**
   * Test for converting DB row to DB Doc.
   */
  public final void testRowToDoc() throws Exception {
    Map<String, Object> rowMap = TestUtils.getStandardDBRow();
    String[] primaryKeys = TestUtils.getStandardPrimaryKeys();
    ProductionTraversalContext context = new ProductionTraversalContext();
    JsonDocument doc = JsonDocumentUtil.rowToDoc("testdb_", primaryKeys,
        rowMap, "localhost", null, null);
    for (String propName : doc.getPropertyNames()) {
      LOG.info(propName + ":    " + getProperty(doc, propName));
    }
    assertEquals("MSxsYXN0XzAx", getProperty(doc, SpiConstants.PROPNAME_DOCID));
    assertEquals("7ffd1d7efaf0d1ee260c646d827020651519e7b0",
        getProperty(doc, ROW_CHECKSUM));
  }

  /**
   * Test case for generateURLMetaFeed().
   */
  public final void testGenerateURLMetaFeed() throws Exception {
    Map<String, Object> rowMap = new HashMap<String, Object>();
    Map<String, Object> rowMapWithBaseURL = new HashMap<String, Object>();
    DBContext dbContext = getDbContext();
    String primaryKeyColumn = "id";
    String[] primaryKeys = { primaryKeyColumn };
    String documentURL = "http://myhost/app/welcome.html";
    String baseURL = "http://myhost/app/";
    String docId = "index123.html";
    String versionColumn = "version";
    String versionValue = "2.3.4";
    // add primary key in row
    rowMap.put(primaryKeyColumn, 1);
    // add document URL in row
    rowMap.put(dbContext.getDocumentURLField(), documentURL);
    // add version column in row
    rowMap.put(versionColumn, versionValue);

    ProductionTraversalContext context = new ProductionTraversalContext();
    JsonDocument doc = JsonDocumentUtil.generateMetadataURLFeed("testdb",
        primaryKeys, rowMap, "localhost", dbContext, "");
    // Test:- column "version" value as metadata.
    assertEquals(versionValue, getProperty(doc, versionColumn));

    // Test:- display URL will be same as the actual URL of the document.
    assertEquals("http://myhost/app/welcome.html", getProperty(doc, 
        SpiConstants.PROPNAME_DISPLAYURL));

    // Test scenario: when base URL is not empty, the display URL is
    // generated by concatenating document id with base URL.
    rowMapWithBaseURL.put(primaryKeyColumn, 2);
    rowMapWithBaseURL.put(dbContext.getDocumentIdField(), docId);
    rowMapWithBaseURL.put(versionColumn, versionValue);

    JsonDocument docWithBaseURL = JsonDocumentUtil.generateMetadataURLFeed(
        "testdb", primaryKeys, rowMapWithBaseURL, "localhost", dbContext,
        JsonDocumentUtil.WITH_BASE_URL);

    // Test:- column "version" value as metadata.
    assertEquals(versionValue, getProperty(docWithBaseURL, versionColumn));

    // Test: display URL of the document.
    assertEquals(baseURL + docId, getProperty(docWithBaseURL, 
        SpiConstants.PROPNAME_DISPLAYURL));
  }

  /**
   * Test case for largeObjectToDoc() method.
   */
  public final void testLargeObjectToDoc() throws Exception {
    Map<String, Object> rowMap = new HashMap<String, Object>();
    Map<String, Object> rowMapWithBaseURL = new HashMap<String, Object>();
    DBContext dbContext = getDbContext();
    // Define common test data.
    String primaryKeyColumn = "id";
    String[] primaryKeys = { primaryKeyColumn };
    String versionColumn = "version";
    String versionValue = "2.3.4";
    String title = "Welcome Page";
    // add primary key in row
    rowMap.put(primaryKeyColumn, 1);
    // add version column in row
    rowMap.put(versionColumn, versionValue);
    // Test scenarios for CLOB data types
    testCLOBDataScenarios(rowMap, primaryKeys);
    // remove CLOB entry from row map which was added in
    // testCLOBDataScenarios().
    rowMap.remove(dbContext.getLobField());
    // Test scenarios for BLOB data types
    testBLOBDataScenarios(rowMap, primaryKeys, dbContext);

    // testPdfBlob(primaryKeys, dbContext);
  }

  /**
   * Test scenarios for CLOB data types.
   *
   * @param rowMap
   * @param primaryKeys
   */
  private void testCLOBDataScenarios(Map<String, Object> rowMap,
        String[] primaryKeys) throws IOException, DBException,
                                     RepositoryException {
    LOG.info("Testing largeObjectToDoc() for CLOB data");
    DBContext dbContext = getDbContext();

    // In iBATIS CLOB data is represented as String or char array.
    // Define CLOB data larger than the FileBackedOutputStream will
    // hold in memory for this test case.
    StringBuilder builder = new StringBuilder(100000);
    Random random = new Random();
    for (int i = 0; i < 100000; i++) {
      builder.append(Character.toChars(32 + random.nextInt(94)));
    }
    String clobContent = builder.toString();
    // set CLOB content. Use alias "dbconn_clob" for column used for storing
    // CLOB data.
    rowMap.put(dbContext.getLobField(), clobContent);

    ProductionTraversalContext context = new ProductionTraversalContext();
    MimeTypeDetector.setTraversalContext(context);
    FileSizeLimitInfo fileSizeLimitInfo = new FileSizeLimitInfo();
    fileSizeLimitInfo.setMaxDocumentSize(5);
    context.setFileSizeLimitInfo(fileSizeLimitInfo);

    JsonDocument clobDoc = JsonDocumentUtil.largeObjectToDoc("testdb_",
        primaryKeys, rowMap, "localhost", dbContext, context);
    // As the size of the document is more than supported, clobDoc should have
    // null value.
    assertNull(clobDoc);
    // Increase the maximum supported size of the document.
    fileSizeLimitInfo.setMaxDocumentSize(1024 * 1024);
    context.setFileSizeLimitInfo(fileSizeLimitInfo);
    clobDoc = JsonDocumentUtil.largeObjectToDoc("testdb_", primaryKeys,
        rowMap, "localhost", dbContext, context);
    assertNotNull(clobDoc);

    // Test scenario:- this doc will have column name "version" as
    // metadata key and value will be "2.3.4".
    assertEquals("2.3.4", getProperty(clobDoc, "version"));

    // Test scenario:- the content of this document will be same as the
    // content of CLOB column(dbconn_clob).
    String actualContent = new String(readBlobContent(clobDoc), "UTF-8");
    assertEquals(clobContent, actualContent);

    // The MIME type of the content should have been automatically determined.
    assertEquals("text/plain",
        Value.getSingleValueString(clobDoc, SpiConstants.PROPNAME_MIMETYPE));

    // Test scenario:- primary key column should be excluded while
    // indexing external metadata.
    assertNull(getProperty(clobDoc, "id"));
  }

  /**
   * Test scenarios for CLOB.
   *
   * @param rowMap
   * @param primaryKeys
   */
  private void testBLOBDataScenarios(Map<String, Object> rowMap,
      String[] primaryKeys, DBContext dbContext)
      throws DBException, RepositoryException {
    LOG.info("Testing largeObjectToDoc for BLOB data");
    // In iBATIS binary content(BLOB) is represented as byte array.
    // Define BLOB data for this test case

    String content = "SOME BINARY DATA";
    byte[] blobContent = content.getBytes();
    rowMap.remove(dbContext.getLobField());
    // set BLOB content
    rowMap.put(dbContext.getLobField(), blobContent);

    // Define for fetching BLOB content
    String fetchURL = "http://myhost:8030/app?dpc_id=120";
    // get Fetch URL value from DBContext
    rowMap.put(dbContext.getFetchURLField(), fetchURL);
    ProductionTraversalContext context = new ProductionTraversalContext();
    MimeTypeDetector.setTraversalContext(context);
    FileSizeLimitInfo fileSizeLimitInfo = new FileSizeLimitInfo();
    fileSizeLimitInfo.setMaxDocumentSize(1024);
    context.setFileSizeLimitInfo(fileSizeLimitInfo);

    JsonDocument blobDoc = JsonDocumentUtil.largeObjectToDoc(
        "testdb_", primaryKeys, rowMap, "localhost", dbContext, context);

    assertNotNull(blobDoc);
    // Test scenario:- this doc will have column name "version" as
    // metadata key and value will be "2.3.4".
    assertEquals("2.3.4", getProperty(blobDoc, "version"));

    // Test scenario:- primary key column should be excluded while
    // indexing external metadata.
    assertNull(getProperty(blobDoc, "id"));

    // If one of the column holds the URL for fetching BLOB data. It
    // will be used as display URL in feed.
    assertEquals(fetchURL,
                 getProperty(blobDoc, SpiConstants.PROPNAME_DISPLAYURL));

    // Set "text/plain" MIME type in unsupported list. Now we should get
    // null value for DB document Content as this document is in unsupported
    // mimetype list.
    Set<String> unsupportedMime = new HashSet<String>();
    unsupportedMime.add("text/plain");
    MimeTypeMap mimeTypeMap = new MimeTypeMap();
    mimeTypeMap.setUnsupportedMimeTypes(unsupportedMime);
    context.setMimeTypeMap(mimeTypeMap);
    JsonDocument.setTraversalContext(context);
    blobDoc = JsonDocumentUtil.largeObjectToDoc("testdb_", primaryKeys,
        rowMap, "localhost", dbContext, context);
    blobDoc.setChanged();
    Property docContent = blobDoc.findProperty(SpiConstants.PROPNAME_CONTENT);
    // Document content should have null value.
    assertNull(docContent);

    // Set "text/plain" MIME type in ignore list. Now we should get null
    // value for DB document as this document is ignored by connector.
    mimeTypeMap.setExcludedMimeTypes(unsupportedMime);
    context.setMimeTypeMap(mimeTypeMap);
    blobDoc = JsonDocumentUtil.largeObjectToDoc("testdb_", primaryKeys,
        rowMap, "localhost", dbContext, context);
    blobDoc.setChanged();
    try {
      blobDoc.findProperty(SpiConstants.PROPNAME_CONTENT);
      fail("Expected SkippedDocumentException, but got none.");
    } catch (SkippedDocumentException e) {
      LOG.info("Skipped Document Exception thrown for ignored mimetype");
    }
  }

  /**
   * Test Case for fetching a BLOB File from Database and dumping it on the file
   * system using JsonDocument Object.
   */
  /* TODO: This does not work because the TESTEMPTABLE has not been set up.
   * And even if it was, it does not have any PDF BLOB data.
   */
  public void testPdfBlob(String[] primaryKeys, DBContext dbContext)
      throws IOException, DBException, RepositoryException {
    DBClient dbClient = getDbClient();
    dbClient.getDBContext().setNumberOfRows(1);
    List<Map<String, Object>> rows = dbClient.executePartialQuery(0,
        dbClient.getDBContext().getNumberOfRows());
    JsonDocument jsonDocument = null;
    for (Map<String, Object> row : rows) {
      jsonDocument = JsonDocumentUtil.largeObjectToDoc("mysql", primaryKeys,
          row, "localhost", dbContext, new ProductionTraversalContext());
    }
    jsonDocument.setChanged();

    byte[] blobcontent = readBlobContent(jsonDocument);
    File newFile = new File("newreport.pdf");
    ByteStreams.write(blobcontent, Files.newOutputStreamSupplier(newFile));
  }

  private byte[] readBlobContent(JsonDocument doc)
      throws IOException, RepositoryException {
    Value value = Value.getSingleValue(doc, SpiConstants.PROPNAME_CONTENT);
    assertNotNull(value);
    InputStream is = ((BinaryValue) value).getInputStream();
    byte[] blobContent = ByteStreams.toByteArray(is);
    is.close();
    return blobContent;
  }    

  private String getProperty(JsonDocument doc, String propName) 
      throws RepositoryException {
    return Value.getSingleValueString(doc, propName);
  }
}
